#!/usr/bin/env node
'use strict'
var Stream = require('stream')
var fs = require('fs')
var SourceStream = require('../lib/gherkin/messages/source_stream')
var MessageStream = require('../lib/gherkin/messages/message_stream')

var args = process.argv.slice(2)
var includes = {
  includeSource: true,
  includeGherkinDocument: true,
  includePickles: true
}

var paths = []
while (args.length > 0) {
  var arg = args.shift()
  switch (arg) {
    case '--no-source':
      includes.includeSource = false;
      break;

    case '--no-ast':
      includes.includeGherkinDocument = false;
      break;

    case '--no-pickles':
      includes.includePickles = false;
      break;

    default:
      paths.push(arg);
  }
}

var ndjsonStream = new Stream.Transform({
  objectMode: true,
  transform: function (message, _, callback) {
    var ob = message.constructor.toObject(message, {defaults:true})
    // This reviver omits printing fields with null values
    var json = JSON.stringify(ob, function(key, value) { return value === null ? undefined : value });
    this.push(json + "\n")
    callback()
  }
})
ndjsonStream.pipe(process.stdout)

function pipeEventsFor(paths, i, callback) {
  var path = paths[i++]
  if (!path) {
    ndjsonStream.end()
    return callback()
  }
  var messageStream = createMessageStream(path)
  messageStream.pipe(ndjsonStream, { end: false })
  messageStream.on('end', () => pipeEventsFor(paths, i, callback))
}

function createMessageStream(path) {
  return fs.createReadStream(path, { encoding: 'UTF-8' })
    .pipe(new SourceStream(path))
    .pipe(new MessageStream(includes))
}

pipeEventsFor(paths, 0, () => ndjsonStream.end())
